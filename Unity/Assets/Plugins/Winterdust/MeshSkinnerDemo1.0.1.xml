<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MeshSkinnerDemo1.0.1</name>
    </assembly>
    <members>
        <member name="T:Winterdust.MeshSkinner">
            <summary>MeshSkinnerDemo 1.0.1 (Winterdust, Sweden). This class enables you to create a working SkinnedMeshRenderer.</summary>
        </member>
        <member name="F:Winterdust.MeshSkinner.VERSION">
            <summary>This build: MeshSkinnerDemo 1.0.1 (Winterdust, Sweden)</summary>
        </member>
        <member name="F:Winterdust.MeshSkinner.DESTROY_ORIGINAL_MESH_RENDERER">
            <summary>0 = Never. 1 = Always. 2 = Do it when not in the Unity editor. When set to NOT being destroyed a GameObject named "SkinnedVersion" is created inside the GameObject containing the MeshFilter/MeshRenderer and "enabled" is set to false on the original MeshRenderer. When in destroy mode the original MeshRenderer is destroyed (as well as its MeshFilter partner). Then no new GameObject created and the SkinnedMeshRenderer component is added to the GameObject that had the original MeshRenderer. This is here due to an issue with the Unity Editor: If you add a SkinnedMeshRenderer to a GameObject with a regular MeshRenderer in play mode Unity will always remove both of them when exiting play mode (with the console message "MeshRenderer component deleted: Obsolete"). This causes the model to disappear instead of reverting to its original state before entering play mode. Hopefully this is fixed in a future version of Unity but right now the SkinnedVersion workaround is needed when play testing in the editor.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.#ctor(UnityEngine.GameObject,UnityEngine.GameObject,System.Single,System.Single,System.String,System.String[],System.Boolean,System.Boolean,System.String,System.String,System.String)">
            <summary>Prepares a mesh to be skinned, call work() and then finish() to actually skin the mesh. Will look for MeshFilter components or (if none are found) already existing SkinnedMeshRenderer components. Position/rotate/scale skeletonGO so that the skeleton aligns with the mesh before calling the constructor (it must be called on Unity's main thread). See each parameter description for full information. Note: A "SkinnedVersion" GameObject is created inside the GameObject containing the MeshFilter component, you can change the static MeshSkinner.DESTROY_ORIGINAL_MESH_RENDERER if you don't want that behaviour. This is a workaround due to an issue with the Unity Editor, see the summary of the static field for more info.</summary>
            <param name="modelGO">The GameObject that will be considered to be your model. Usually in Unity this is the GameObject that has an Animation/Animator component and it has one or several child GameObjects. These children are then the ones containing the actual meshes of the model. MeshSkinner will check the given modelGO as well as all its children for meshes.</param>
            <param name="skeletonGO">The GameObject that contains all the GameObjects that make up your skeleton. MeshSkinner will make skeletonGO a child of modelGO (usual model structure in Unity). Note: skeletonGO is usually not itself part of the skeleton, it is just the skeleton container. You can set rootBoneName to null if you want to use skeletonGO as the actual root bone.</param>
            <param name="quickFixNeckBoneReach">Set this to -1 to not call quickFix(). Otherwise quickFix() is called with the default values except "neckBoneReach", which is what you specify here. If the head joint is above the mesh's chin the neck bone needs to be shortened, that is what this percentage does. Else the chin part of the mesh would lag behind the rest of the head mesh when turning.</param>
            <param name="squareBoundsSize">Keep this as 0 to not call setRenderBoundsModifierAsSquare() and have the render bounds fit the mesh exactly. Set it to 1 to make all sides of the bounds have equal length. Over 1 will add extra length to all sides. Less than 1 will make the bounds not cover the whole mesh and isn't recommended.</param>
            <param name="rootBoneName">Keep this as an empty string to make the first child GameObject of skeletonGO the root bone. Set it to null to make the given skeletonGO the root bone. Otherwise give a GameObject's name to make it the root bone (exact name match, except for letter case). If the root bone can't be found a NullReferenceException will be thrown.</param>
            <param name="meshesToProcessExactGONames">When null all meshes encountered will be skinned. Otherwise the string[] array must contain the name of the GameObject that contains the component with the mesh, or else the mesh will be ignored. Letter case doesn't matter, otherwise the name must always match exactly.</param>
            <param name="countRootBoneAsSkeletonOrigin">Used only to determine the joint plane rotation of the root bone. Set this to true if you want that plane's normal to just point towards the child joint, keep it as false to allow it to have a different rotation determined by the root bone's position from the skeletonGO position.</param>
            <param name="modelFrontFacingTowardsPositiveZ">A common practice is to model a mesh with its front appearance towards the camera and the camera looking towards the negative Z. You can set this to false if the mesh is not like that. Note: This bool is only used during the work() call if tiltJointBackForth(), tiltJointLeftRight() or spinJointLeftRight() was called beforehand.</param>
            <param name="qfSpineJointNames">Transform names containing these strings are assumed to be spine joints. Given string is split on comma. This is only used by the quickFix() method.</param>
            <param name="qfClavicleJointNames">Transform names containing these strings are assumed to be clavicle (shoulder) joints. Given string is split on comma. This is only used by the quickFix() method.</param>
            <param name="qfNeckJointNames">Transform names containing these strings are assumed to be neck joints. Given string is split on comma. This is only used by the quickFix() method.</param>
        </member>
        <member name="M:Winterdust.MeshSkinner.ToString">
            <summary>Returns a string in this format: MeshSkinner "modelGO.name"+"skeletonGO.name" (# meshes, # vertices, # triangles, # proper bones, # bone ends). Work done: YES/NO. Finished: YES/NO.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.setRenderBoundsModifier(UnityEngine.Vector3)">
            <summary>Modifies the bounds of the SkinnedMeshRenderer by multiplying its dimensions with the given XYZ. (Returns this MeshSkinner instead of void, for chaining.) Note: The SkinnedMeshRenderer will not render unless its bounds is in view of a camera (except if "update when offscreen" is set to true by you of course). If your skeleton animation moves the mesh outside the bounds it's possible that the camera will not see it even though it should, therefore it is a good idea to make the bounds a bit larger than just the mesh in its rest pose - to make sure all animated frames of the mesh is also covered.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.setRenderBoundsModifier(System.Single,System.Single,System.Single)">
            <summary>Modifies the bounds of the SkinnedMeshRenderer by multiplying its dimensions with the given XYZ. (Returns this MeshSkinner instead of void, for chaining.) Note: The SkinnedMeshRenderer will not render unless its bounds is in view of a camera (except if "update when offscreen" is set to true by you of course). If your skeleton animation moves the mesh outside the bounds it's possible that the camera will not see it even though it should, therefore it is a good idea to make the bounds a bit larger than just the mesh in its rest pose - to make sure all animated frames of the mesh is also covered.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.setRenderBoundsModifierAsSquare(System.Single)">
            <summary>Modifies the bounds of the SkinnedMeshRenderer by setting its dimensions to the same value (the largest of the original values) and then multiplying that by the given size. The bounds will be a cube with equal-length sides. (Returns this MeshSkinner instead of void, for chaining.) Note: The SkinnedMeshRenderer will not render unless its bounds is in view of a camera (except if "update when offscreen" is set to true by you of course). If your skeleton animation moves the mesh outside the bounds it's possible that the camera will not see it even though it should, therefore it is a good idea to make the bounds a bit larger than just the mesh in its rest pose - to make sure all animated frames of the mesh is also covered.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.quickFix(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>This method is meant to provide some basic modifiers that improves the end result of the skinning. It's usually called from the constructor but you can call it manually for more control. It uses typical spine, clavicle and neck names to identify which joints to work with (loose name matching is always used). These joint names are specified in the constructor. See each parameter description for full information.</summary>
            <returns>This MeshSkinner instance, for possible chaining of method calls on the same line.</returns>
            <param name="neckBoneReach">This value determines how much of the space between the neck joint and its child that actually belongs to the neck joint. Shortening the neck might be needed to prevent the chin part of the head mesh from being influenced by the neck joint when rotating the head joint.</param>
            <param name="neckChild_BackForthTilt">How many degrees to tilt the neck's joint plane (positive values tilts backwards, negative forwards). The default -15 tilts the plane a bit forwards, which is good if the neck mesh is longer in the back than it is in the front (typical in meshes where something sticks out in front of the head, for example a jaw).</param>
            <param name="spine_BendRange">How far spine joints should spread their influence between each other, setJointBendyness() is called for each spine joint with jointNameController set to each other spine joint.</param>
            <param name="spine_BendFactor">How much smoothing that should be used between each spine joint. A higher value equals more persistent influence by a joint even further away from the influence source.</param>
            <param name="clavicleChild_BendRange">How far children of clavicle joints should spread their influence between itself and its parent (the clavicle). setJointBendyness() is called for each clavicle child with "PARENT" as jointNameController. Note: The typical child joint is usually the model's upper arm, however these have great variation in name (for example Arm1/Biceps/UArm) so they are found via the clavicle (shoulder) joint instead.</param>
            <param name="clavicleChild_BendFactor">How much smoothing that should be used between between the clavicle child joint and its parent (the clavicle). A higher value equals more persistent influence by a joint even further away from the influence source.</param>
            <param name="neck_BendRange">How far neck joints should spread their influence between itself and any other joint. setJointBendyness() is called for each child with null as jointNameController. Note: It's typical that both spine and clavicle joints spread their influence into the neck, as well as the head joint. However, the relationship between the neck and head joints will typically be defined by neckChild_BendRange and neckChild_BendFactor instead (overrides neck_BendRange and neck_BendFactor).</param>
            <param name="neck_BendFactor">How much smoothing that should be used between between the neck joint and whatever else joint that is spreading into it. A higher value equals more persistent influence by a joint even further away from the influence source.</param>
            <param name="neckChild_BendRange">How far children of neck joints should spread their influence between itself and its parent (the neck). setJointBendyness() is called for each neck child with "PARENT" as jointNameController. Note: Typically the head joint comes after the neck joint. Note 2: neckChild_BendRange and neckChild_BendFactor overrides neck_BendRange and neck_BendFactor for the relationship(s) between the neck and its child(ren).</param>
            <param name="neckChild_BendFactor">How much smoothing that should be used between between the neck child joint and its parent (the neck). A higher value equals more persistent influence by a joint even further away from the influence source.</param>
            <param name="clavicleJointsMustBeChildOfSpineJoints">When false only the name of the joint need to be that of a clavicle joint, otherwise with the default behaviour the clavicle also needs to have a spine joint as its parent. (This extra check is useful since sometimes the upper arm joints are named "shoulder" even though they aren't really a clavicle joint.)</param>
            <param name="neckJointsMustBeChildOfSpineJoints">When false only the name of the joint need to be that of a neck joint, otherwise with the default behaviour the neck also needs to have a spine joint as its parent.</param>
        </member>
        <member name="M:Winterdust.MeshSkinner.paintWeightSphere(System.String,UnityEngine.Vector3,System.Single,System.Boolean,System.Boolean,System.String[])">
            <summary>All vertices that are inside the given sphere will get influenced by the specified joint. See summary of paintWeightGO() for info about overrideOtherPaint/looseNameMatching/meshesToProcessExactGONames. (Returns this MeshSkinner instead of void, for chaining.)</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.paintWeightBox(System.String,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Boolean,System.Boolean,System.String[])">
            <summary>All vertices that are inside the given box will get influenced by the specified joint. The box is defined like the UnityEngine.Bounds struct, with the addition of a rotation (use Quaternion.identity for no rotation). See summary of paintWeightGO() for info about overrideOtherPaint/looseNameMatching/meshesToProcessExactGONames. (Returns this MeshSkinner instead of void, for chaining.)</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.paintWeightGO(System.String,UnityEngine.GameObject,System.Boolean,System.Boolean,System.Boolean,System.String[])">
            <summary>Looks for BoxCollider and SphereCollider components in the given GameObject and its children. All mesh vertices inside these colliders will become influenced by the given joint. See each parameter description for full information.</summary>
            <returns>This MeshSkinner instance, for possible chaining of method calls on the same line.</returns>
            <param name="jointName">Name of a transform that is part of the skeleton. This is the influence you are painting.</param>
            <param name="goWithBoxOrSphereColliders">The GameObject that will be scanned for BoxColliders and SphereColliders (in the given GO itself and sub-GameObjects as well).</param>
            <param name="overrideOtherPaint">When false a vertex will not get painted by this if it has already been painted by another paint method already. When true it's always the last paint call that sets the final influence.</param>
            <param name="destroyGO">When true GameObject.Destroy(goWithBoxOrSphereColliders); is called at the end of this method.</param>
            <param name="looseNameMatching">When true the transform name need only contain the given jointName to count as the joint you are after. When false the transform name must match jointName exactly. Note: Letter case is always ignored.</param>
            <param name="meshesToProcessExactGONames">When null all meshes encountered will be painted. Otherwise the string[] array must contain the name of the GameObject that contained the component with the mesh, or else the mesh will be ignored. Letter case doesn't matter, otherwise the name must always match exactly.</param>
        </member>
        <member name="M:Winterdust.MeshSkinner.paintWeightDirect(System.String,System.Int32[],System.Boolean,System.String[])">
            <summary>If you know the indexes of the vertex positions you wish to assign a certain influence you can do so here. The given int[] array are indexes in the Vector3[] "vertices" array of the mesh. See summary of paintWeightGO() for info about looseNameMatching/meshesToProcessExactGONames. (Returns this MeshSkinner instead of void, for chaining.) Note: Always overrides already-existing paint and paintWeightDirect()/paintWeightPoints() calls are executed AFTER paintWeightGO()/paintWeightSphere()/paintWeightBox() calls, meaning "precision painting" supersedes painting done by specifying volumes.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.paintWeightPoints(System.String,UnityEngine.Vector3[],System.Single,System.Boolean,System.String[])">
            <summary>Loops through the given world positions. The mesh vertex closest to the given world position is assigned the given influence (jointName). One world position will influence max one mesh vertex, even if there are several meshes. The distance can be used to limit how far away from a mesh point a given world point is allowed to be (-1 to allow any distance). See summary of paintWeightGO() for info about looseNameMatching/meshesToProcessExactGONames. (Returns this MeshSkinner instead of void, for chaining.) Note: Always overrides already-existing paint and paintWeightDirect()/paintWeightPoints() calls are executed AFTER paintWeightGO()/paintWeightSphere()/paintWeightBox() calls, meaning "precision painting" supersedes painting done by specifying volumes.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.setJointBendyness(System.String,System.Single,System.Single,System.Boolean,System.String)">
            <summary>Allows you to make a joint more (or less) "bendy" by increasing the influence distance of other nearby joints. See each parameter description for full information.</summary>
            <returns>This MeshSkinner instance, for possible chaining of method calls on the same line.</returns>
            <param name="jointName">Name of a transform that is part of the skeleton. This is the joint that will become more/less "bendy", meaning when you rotate this joint the mesh will either deform at greater or lesser distance away from the joint itself.</param>
            <param name="bendRange">How far this joint's influence should be spread into another joint's influence (and vice versa). 0 means that these two influences should not be spread into each other, 1 means they should be spread fully into each other. 0.25 is the usual default. 2 gives twice the range. Note: This "range" is calculated automatically from the available influences at a time when nothing has been spread yet, if the mesh is not completely straight between two joints (as it rarely is) or if several influences are colliding the ranges will be approximations. The smallest calculated range of the influences next to each other are the one used.</param>
            <param name="bendFactor">This affects how smoothly the influence is reduced over distance when spreading into another influence. 0 means the bendRange might as well have been 0 as well (spreading influence drops off immediately). 1 means the influence drops off fully evenly throughout the spread distance. -1 will set this to the given bendRange, which usually gives a decent result.</param>
            <param name="looseNameMatching">When true the transform name need only contain the given jointName to count as the joint you are after. When false the transform name must match jointName exactly. Note: Letter case is always ignored.</param>
            <param name="jointNameController">This joint name is used when determining if the rule should be applied or not. If influence A and B are next to each other one of them need to be jointName and the other jointNameController in order for the rule to apply to this relationship. The default "PARENT" assigns the jointNameController automatically to the parent joint, which usually gives the desired behaviour. Set this to null to make the rule apply to all influence relationships, as long as one of the influences is jointName. Example: Say that LowerArm can spread its influence into both UpperArm and Hand. [jointName=LowerArm,jointNameController=PARENT] will make the LowerArm joint bendy because the rule is only applied to the LowerArm-UpperArm relationship. [jointName=LowerArm,jointNameController=null] will make both LowerArm and Hand bendy because the rule is only applied to both the LowerArm-UpperArm relationship and the LowerArm-Hand relationship.</param>
        </member>
        <member name="M:Winterdust.MeshSkinner.setRelationshipHeat(System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>Allows you to set spread distance directly between influences. This overrides anything given to setJointBendyness(), in which the spread distance is calculated from the given bendRange instead. A "relationship" is two vertices next to each other that are influenced by different joints. The word "heat" represents how far they will spread their own influence into each other. Usually you want this to be the same in both ways but you can set onlyApplyToJointNameA to true if you only want to apply this rule in one direction (influence A spreading into influence B). See the summary of setJointBendyness() for more info on the other parameters. (Returns this MeshSkinner instead of void, for chaining.) Note: If a vertex is next to several different influences and has a "relationship heat" rule with several of these neighbours, then the rule with the smallest spreadDistanceUnityUnits is used (along with the bendFactor given with it).</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.setJointForward(System.String,UnityEngine.Vector3,System.String,System.Boolean)">
            <summary>Rotates the joint plane so its forward direction is the given globalForward. You can use jointNameTail to specify an exact bone, when null this applies to all bones that a single joint can produce if it has several children). Set looseNameMatching to false to require exact joint names, except letter case. What is a "joint plane"? It's basically an imaginary plane that is used to determine if a vertex should be influenced by the transform, its parent or its child. You can use the debug() method after work() is done to visualize these planes. (Returns this MeshSkinner instead of void, for chaining.) Note: This does not take the model's rotation into account, the given globalForward will be the forward of the plane regardless of how the model is rotated.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.tiltJointBackForth(System.String,System.Single,System.String,System.Boolean)">
            <summary>Rotates the joint plane on the model's x axis (will take model rotation into account). Positive degrees = back tilt, negative = forth tilt. Which way is the model's front gets decided in the constructor and can be flipped using the modelFrontFacingTowardsPositiveZ parameter. You can use jointNameTail to specify an exact bone, when null this applies to all bones that a single joint can produce if it has several children). Set looseNameMatching to false to require exact joint names, except letter case. See the summary of setJointForward() to know what a "joint plane" is. (Returns this MeshSkinner instead of void, for chaining.)</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.tiltJointLeftRight(System.String,System.Single,System.String,System.Boolean)">
            <summary>Rotates the joint plane on the model's z axis (will take model rotation into account). Positive degrees = left tilt, negative = right tilt. Which way is the model's front gets decided in the constructor and can be flipped using the modelFrontFacingTowardsPositiveZ parameter. You can use jointNameTail to specify an exact bone, when null this applies to all bones that a single joint can produce if it has several children). Set looseNameMatching to false to require exact joint names, except letter case. See the summary of setJointForward() to know what a "joint plane" is. (Returns this MeshSkinner instead of void, for chaining.)</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.spinJointLeftRight(System.String,System.Single,System.String,System.Boolean)">
            <summary>Rotates the joint plane on the model's y axis (will take model rotation into account). Positive degrees = left spin, negative = right spin. Which way is the model's front gets decided in the constructor and can be flipped using the modelFrontFacingTowardsPositiveZ parameter. You can use jointNameTail to specify an exact bone, when null this applies to all bones that a single joint can produce if it has several children). Set looseNameMatching to false to require exact joint names, except letter case. See the summary of setJointForward() to know what a "joint plane" is. (Returns this MeshSkinner instead of void, for chaining.)</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.setBoneReach(System.String,System.Single,System.String,System.Boolean)">
            <summary>Determines how much of the space between the bone's head and its tail actually belong to itself. boneReach works as a "bone count"; the distance is in number of bones, not in the percentage length of the current bone. See each parameter description for full information. Note: Call setBoneReach() on joints closer to the root bone in the hierarchy last if you for example want a bone to own part of its child's bone but not the first part of its own bone (first decide the reach of the child and then the reach of the child's parent).</summary>
            <returns>This MeshSkinner instance, for possible chaining of method calls on the same line.</returns>
            <param name="jointNameHead">Name of a transform that is part of the skeleton. This is where the bone begins. Joints that are at the end of the skeleton hierarchy can't modify their bone reach because they are childless, if you want to set their reach to 0 you can set their parent's reach to 2 instead.</param>
            <param name="boneReach">How many bones, counting from jointNameHead, that should belong to jointNameHead. Examples: 0.5 = first half of my bone belongs to me, second half to my child. 1.5 = all of my bone and half of my child's bone belongs to me. 3.25 = My bone as well as the 2 following bones fully belong to me, then the first 25% if the next bone also belongs to me.</param>
            <param name="jointNameTail">Name of a transform that is part of the skeleton. This is where the bone ends. If null you are not setting the reach of a specific bone, the reach will apply to all bones that originates from jointNameHead (if that transform has just one child it doesn't matter).</param>
            <param name="looseNameMatching">When true the transform name need only contain the given jointName to count as the joint you are after. When false the transform name must match jointName exactly. Note: Letter case is always ignored.</param>
        </member>
        <member name="M:Winterdust.MeshSkinner.setBoneAsDisabled(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>Disables a bone. A disabled bone will not seed influence or prevent other bones from expanding (during the 'fill phase' inside the work() method). You can use jointNameTail to specify an exact bone, when null this applies to all bones that a single joint can produce if it has several children). Set looseNameMatching to false to require exact joint names, except letter case. The last bool can be used to reverse bone disables, for example those coming from the fact that a joint is outside the mesh. (Returns this MeshSkinner instead of void, for chaining.)</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.workAndFinish(System.Single,System.Single,System.Boolean,System.Boolean,System.Boolean,Winterdust.MeshSkinner.ProgressTracker,Winterdust.MeshSkinner,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Does the exact same thing as first calling work() and then finish(). This just saves you from doing the second call yourself. You can use this if you are only using MeshSkinner from Unity's main thread (no multi-threaded loading). See summary of work() and finish() for more info.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.work(System.Single,System.Single,System.Boolean,System.Boolean,System.Boolean,Winterdust.MeshSkinner.ProgressTracker,Winterdust.MeshSkinner,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Executes the main work load of skinning the mesh. This can be done on a different thread other than Unity's main thread! After work is done you need to call finish() back on Unity's main thread. See each parameter description for full information. Note: Any kind of bone-disable happening through the parameters of the work() method may be undone by you if you have called setBoneAsDisabled() with actuallyEnableBoneInstead set to true before calling work(). Note 2: Bone-disables that happened inside work() of the given OTHER instance of MeshSkinner will not get copied. It's THIS instance's work() paramaters that applies.</summary>
            <returns>This MeshSkinner instance, for possible chaining of method calls on the same line.</returns>
            <param name="defaultJointBendRange">The default bend range to use for a joint if setJointBendyness() or setRelationshipHeat() has not been called for it. See summary of setJointBendyness() for more info on bend range (in short it's how far influence spread into a different influence, 1 equals 100% of the calculated range of the influence being spread into).</param>
            <param name="defaultJointBendFactor">The default bend factor to use for a joint if setJointBendyness() or setRelationshipHeat() has not been called for it. See summary of setJointBendyness() for more info on bend factor (in short it's how smoothly influence should spread, a higher value means a more even influence reduction over distance).</param>
            <param name="ignoreJointsUntilInsideMesh">When true joints that are outside the mesh will become disabled until one is inside the mesh (following the skeleton hierarchy). Children of the first joint inside the mesh may stray outside the mesh without being disabled (unless ignoreAllJointsOutsideMesh is set to true).</param>
            <param name="ignoreAllJointsOutsideMesh">When true all joints that are outside the mesh will become disabled. In effect this will make ignoreJointsUntilInsideMesh become true, even if you set it to false.</param>
            <param name="ignoreZeroLengthBones">When true joints that begins and ends on the same world position will become disabled. Joints at the end of the hierarchy that have no children never gets disabled because of this (they don't count as having zero length).</param>
            <param name="progressTracker">If you wish to check the status of the work from a different thread in your program you can give a MeshSkinner.ProgressTracker here. Otherwise keep this as null.</param>
            <param name="otherAlreadyWorkDoneMeshSkinnerToCopyStuffFrom">If this model uses the exact same skeleton structure (transform hierarchy) as a different model that you've already processed with a different MeshSkinner instance you can save several milliseconds by copying things from there. Simply give the instance reference here. Keep null here to not copy anything (the rest of the parameters beginning with "copy" will be ignored). Note: The given instance's isWorkDone() must return true! It doesn't matter what its isFinished() returns though.</param>
            <param name="copyBoneSizeDefinition">When true this could be a big time saver (assuming that otherAlreadyWorkDoneMeshSkinnerToCopyStuffFrom isn't null of course). It allows the work() method to skip the 'fill phase' and just mimick the bones in the given MeshSkinner instance. That's why it's important that the other instance has the exact same skeleton structure (transform hierarchy). If the skeleton isn't built exactly the same, set this to false.</param>
            <param name="copyJointBendyness">Applies all setJointBendyness() calls that were made on the OTHER instance to THIS instance (including those made inside quickFix()). Note: Any setJointBendyness() calls made on THIS instance will still override those made on the OTHER instance (including those made inside THIS instance's quickFix()).</param>
            <param name="copyRelationshipHeat">Applies all setRelationshipHeat() calls that were made on the OTHER instance to THIS instance. Note: Any setRelationshipHeat() calls made on THIS instance will still override those made on the OTHER instance.</param>
            <param name="copyBoneReach">Applies all setBoneReach() calls that were made on the OTHER instance to THIS instance (including those made inside quickFix()). Note: Any setBoneReach() calls made on THIS instance will still override those made on the OTHER instance (including those made inside THIS instance's quickFix()).</param>
            <param name="copyBoneDisables">Applies all setBoneAsDisabled() calls that were made on the OTHER instance to THIS instance (including those made inside quickFix()). Note: Any setBoneAsDisabled() calls made on THIS instance will still override those made on the OTHER instance (including those made inside THIS instance's quickFix()).</param>
            <param name="copyJointTiltSpinForward">Applies all tiltJointBackForth()/tiltJointLeftRight()/spinJointLeftRight()/setJointForward() calls that were made on the OTHER instance to THIS instance (including those made inside quickFix()). Note: Any tiltJointBackForth()/tiltJointLeftRight()/spinJointLeftRight()/setJointForward() calls made on THIS instance will still override those made on the OTHER instance (including those made inside THIS instance's quickFix()).</param>
            <param name="copyWeightPaint">Applies all paintWeightGO()/paintWeightSphere()/paintWeightBox()/paintWeightDirect()/paintWeightPoints() calls that were made on the OTHER instance to THIS instance (including those made inside quickFix()). Note: Any paintWeightGO()/paintWeightSphere()/paintWeightBox()/paintWeightDirect()/paintWeightPoints() calls made on THIS instance will still override those made on the OTHER instance (including those made inside THIS instance's quickFix()).</param>
        </member>
        <member name="M:Winterdust.MeshSkinner.isWorkDone">
            <summary>Returns true if work() is done. When true is returned you can call finish() to finalize the skinning process (it is safe to call finish() at any time though, even before the work is done). You can call debug() after work is done and get the then-available joint planes added to the DebugWeights component (debug() can be called at any time but no joint planes are available until after the work is done). If this returns true it also means that you can give this MeshSkinner instance to the work() method of a different MeshSkinner instance via the otherAlreadyWorkDoneMeshSkinnerToCopyStuffFrom parameter.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.isFinished">
            <summary>Returns true if work() is done and finish() has been called and returned true. When a MeshSkinner is finished the instance can be discarded, unless you want to give it to another MeshSkinner's work() method (it saves some processing time if both use the same skeleton structure).</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.finish">
            <summary>This method needs to be called from Unity's main thread once work() is done. Returns true if this is the call that actually finishes the MeshSkinner, additional calls will always return false if the MeshSkinner has already finished. Calls before work() has begun or before work() is done can be performed safely and also returns false. Use isFinished() if you need to check if finish() has ever returned true on this instance.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.finishAlt">
            <summary>Does the exact same thing as finish(), except that it returns this instance of MeshSkinner instead of true/false. You can use this method if you know finish() would have returned true and you want to be able to chain commands on the same line of code. See summary of finish() for more info.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.debug(System.Single,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)">
            <summary>Adds a DebugWeights component to the modelGO given in the constructor by calling the static MeshSkinner.debugWeights() function. Then --if work() is done-- the joint planes are added to the DebugWeights component. The component check the GameObject and its children for SkinnedMeshRenderer components and then draw colored lines to illustrate the most dominant influence for each vertex. It's important to remember that a vertex can have up to four influences (max allowed by Unity) but only the biggest will be visualized. See each parameter description for full information. Note: These lines will show up outside the Unity Editor as well.</summary>
            <returns>This MeshSkinner instance, for possible chaining of method calls on the same line. Note: Use debugAlt() to return the added DebugWeights component instead.</returns>
            <param name="pointSize">When over zero this will draw a little plus at each vertex. Note: The lines will have a length of this value divided by 10.</param>
            <param name="drawTriangleEdges">Draw a line on the mesh between neighbouring vertices that share the same influence.</param>
            <param name="drawBoneLines">Draw a line from the vertex to its main influence (the transform's position). You may need to set the scene's Shading Mode in the Unity Editor to "Wireframe" in order to see these lines. You can also turn on xray, however then you will lose depth checking and some lines might appear in front of another when they aren't.</param>
            <param name="xray">When true all lines will render on top of everything else, including each other.</param>
            <param name="alsoUseDarkColors">Expands the line color pool with dark versions of the same colors (Cyan, Green, Magenta, Red, Yellow, Orange).</param>
            <param name="onlyBorderEdges">When true only triangle edges that are in the outskirts of the influence area will be drawn. This saves render performance, set to false to draw all triangles. Note: Has no effect if drawTriangleEdges is false.</param>
            <param name="jointPlaneSize">When non-zero this will draw joint planes to illustrate their position and rotation. A positive size will use white color, a negative size will use black color. These (imaginary) planes are used to determine if a vertex should be influenced by the joint's own transform, its parent or its child. Important: If debug() is called before work() this remains as 0 since joint planes only are available after work is done.</param>
        </member>
        <member name="M:Winterdust.MeshSkinner.debugAlt(System.Single,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Single)">
            <summary>Does the exact same thing as debug(), except that it returns the MeshSkinnerDebugWeights component added to the modelGO given to the instance constructor instead of the instance itself. See summary of debug() for more info.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.debugWeights(UnityEngine.GameObject,System.Single,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Allows debugging of all SkinnedMeshRenderer components, not just those created via this MeshSkinner. See summary of the non-static debug() method for more info. Note: Joint planes will not be available via this method, changing "jointPlaneSize" from 0 will have no effect.</summary>
            <returns>The MeshSkinnerDebugWeights component added to the given modelGO.</returns>
        </member>
        <member name="T:Winterdust.MeshSkinner.ProgressTracker">
            <summary>Create an instance of this class and give it to the MeshSkinner's work() method if you want to be able to check the progress from a different thread.</summary>
        </member>
        <member name="F:Winterdust.MeshSkinner.ProgressTracker.progress">
            <summary>The MeshSkinner class writes to this double while working. Is always reset to 0 when work starts. When this is 1.0 the work has finished.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinner.ProgressTracker.getPercentage(System.Int32,System.Int32)">
            <summary>Returns a formatted version of percentLoaded. Example: If percentLoaded is 0.5 this will return "50" when decimals is 0 and "50.00" when decimals is 2. Change minimumIntegers if you want a minimum length on the left side of the dot, "050.0000" would be returned if decimals are 4 and minimumIntegers is 3.</summary>
        </member>
        <member name="T:Winterdust.MeshSkinnerDebugWeights">
            <summary>This component is added to the modelGO when calling debug(), debugAlt() or MeshSkinner.debugWeights(). It's used to draw the visualize all found SkinnedMeshRenderer components (child transforms are checked as well). The "Hidden/Internal-Colored" shader is used and lines are drawn using the GL class in OnRenderObject().</summary>
        </member>
        <member name="F:Winterdust.MeshSkinnerDebugWeights.drawBoneLines">
            <summary>Draw a line from the vertex to its main Transform influence.</summary>
        </member>
        <member name="F:Winterdust.MeshSkinnerDebugWeights.drawTriangleEdges">
            <summary>Draw a line on the mesh between neighbouring vertices that share the same influence.</summary>
        </member>
        <member name="F:Winterdust.MeshSkinnerDebugWeights.drawPoints">
            <summary>Draw a little plus at each vertex. Set to 0 or below to disable. Note: The lines will have a length of this value divided by 10.</summary>
        </member>
        <member name="F:Winterdust.MeshSkinnerDebugWeights.xray">
            <summary>Should the lines be visible through walls?</summary>
        </member>
        <member name="F:Winterdust.MeshSkinnerDebugWeights.alsoUseDarkColors">
            <summary>Expand the line color pool with darker versions?</summary>
        </member>
        <member name="F:Winterdust.MeshSkinnerDebugWeights.boneIndex">
            <summary>Skip vertices that don't have this as main influence (index in the SkinnedMeshRenderer's "bones" array). -1 to not skip anything.</summary>
        </member>
        <member name="F:Winterdust.MeshSkinnerDebugWeights.onlyBorderEdges">
            <summary>Only draw triangle edges that are in the outskirts of the influence area? This saves performance when true. Has no effect if drawTriangleEdges is false.</summary>
        </member>
        <member name="F:Winterdust.MeshSkinnerDebugWeights.jointPlaneSize">
            <summary>Draw planes at the joints to help visualize their tilt. Set to 0 to disable. Over 0 gives white planes, below 0 gives black planes. Note: This does nothing unless AddJointPlane() has been called at least once.</summary>
        </member>
        <member name="M:Winterdust.MeshSkinnerDebugWeights.AddJointPlane(UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Quaternion)">
            <summary>Adds a "joint plane" that will be drawn when jointPlaneSize is set to other than 0. These visualize how joints are "tilted" towards their child/parent. This (imaginary) plane is used to determine if a vertex should be influenced by the transform, its parent or its child. See each parameter description for full information.</summary>
            <param name="owner">A transform representing a joint in the skeleton.</param>
            <param name="position">Where the plane origin is (in world space) when all joints are in their rest position.</param>
            <param name="rotation">The "tilt" of the joint. When all joints are in their rest position the plane will have this rotation.</param>
        </member>
    </members>
</doc>
